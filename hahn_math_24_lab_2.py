# -*- coding: utf-8 -*-
"""Hahn Math 24 Lab 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IEV3ROUnzEcKPnkao5rGQtNc9JFkXCrn
"""

import numpy as np
import matplotlib.pyplot as plt

numbers= np.array([1,2,2,3,3,3,4,4,4,4])

plt.hist(numbers,100);

"""# PRNG

See Here!!
[PRNG Lab 2.5](https://colab.research.google.com/drive/1HUZPmRsPI6vNPKnMhgIvFpDS14AAP8w7?usp=sharing)
"""

x = 0.12345

x = x*3

x % 1

current_point = 0.12345          # seed value
points_to_save = np.zeros(50000,)  # initialize an array of zeros

for i in range(X.shape[0]):
    current_point = 3*current_point % 1      # update x and store the value in X
    points_to_save[i] = current_point

plt.plot(points_to_save, '.')     # plot the values in X

plt.hist(points_to_save);

def coin():
    return 2*(np.random.random() > 0.5) - 1

coin()

x = 0
x + coin()

x = 0

for i in range(3):
    x = x + coin()

x

x = 0

for i in range(100):
    x = x + coin()

x

M = 10000
N = 100

X = np.zeros(M,)

for j in range(M):

    x = 0

    for i in range(N):
        x = x + coin()

    X[j] = x

plt.hist(X);



"""# Bonus: Explain Pascal's Triangle"""

P = np.zeros((12,18))

P[0,5]=1

for i in range(1,P.shape[0]):

    for j in range(1,P.shape[1]-1):

        P[i,j] = P[i-1,j-1]+P[i-1,j]

print(P[:,5:])

"""# Normal Distribution"""

# Define the parameters for the normal distribution
mean = 0  # Mean (mu) of the distribution
std_dev = 0.1  # Standard deviation (sigma) of the distribution

# Generate 1000 data points following a normal distribution with the specified mean and standard deviation
sample_size = 10000
data_points = np.random.normal(mean, std_dev, sample_size)

# Plot the histogram of the data points
bins_number = 30  # Number of bins for the histogram
hist_count, x, ignored = plt.hist(data_points, bins_number, density=True)

x = np.linspace(-15,15,1000)

y = np.exp(-x**2)

plt.plot(x,y)

y2 = np.sin(10*x)

plt.plot(x,y2)

plt.plot(x,y*y2)

y3 =  np.exp(- (x - 0) ** 2 )
plt.plot(x, y3, linewidth=2, color='r')

# Define the parameters for the normal distribution
mean = 0  # Mean (mu) of the distribution
std_dev = 0.1  # Standard deviation (sigma) of the distribution

# Generate 1000 data points following a normal distribution with the specified mean and standard deviation
sample_size = 10000
data_points = np.random.normal(mean, std_dev, sample_size)

# Plot the histogram of the data points
bins_number = 30  # Number of bins for the histogram
hist_count, x, ignored = plt.hist(data_points, bins_number, density=True)

# Plot the probability density function of the normal distribution
normal_dist_curve = 1 / (std_dev * np.sqrt(2 * np.pi)) * np.exp(- (x - mean) ** 2 / (2 * std_dev ** 2))
plt.plot(x, normal_dist_curve, linewidth=2, color='r')

# Set the title and labels for the plot
plt.title('Normal Distribution Visualization')
plt.xlabel('Value')
plt.ylabel('Probability Density')

# Display the plot
plt.show()



x = np.array([1,2,3,4])

np.sum(x)

x.shape[0]

np.sum(x)/x.shape[0]

def mean(x):
    return np.sum(x)/x.shape[0]

mean(x)

x

x - mean(x)

(x - mean(x))**2

def var(x):
    return mean((x - mean(x))**2)

def std(x):
    return np.sqrt(var(x))

mean(x)

var(x)

std(x)



"""### Uniform Random Numbers"""

X = np.random.random(500000,)

X

plt.hist(X,100);

np.random.random()

r = np.random.random()

r

r = np.random.randint(1,10)

r

np.random.randn()

numbers  = np.random.randn(2,4)

numbers.shape

numbers = numbers.reshape(-1)

numbers.shape

numbers= np.array([1,2,2,3,3,3,4,4,4,4])

plt.hist(numbers,100);

numbers = np.random.randn(100000,)
plt.hist(numbers,100);

numbers = np.random.rand(1000000,)
plt.hist(numbers,100);

np.random.seed(12345)
data = np.random.randn(2, 100)

plt.figure(1, figsize=(9, 9))

plt.subplot(2,2,1)
plt.hist(data[0])

plt.subplot(2,2,2)
plt.scatter(data[0], data[1])

plt.subplot(2,2,3)
plt.plot(data[0], data[1],'-')

plt.subplot(2,2,4)
plt.hist2d(data[0], data[1])

plt.show()

"""Normal Dist Data"""

x = 10*np.random.randn(10000)

plt.hist(x);

x = np.random.rand(1000,)

plt.hist(x);



mu = 0  # mean of distribution
sigma = 1  # standard deviation of distribution
x = mu + sigma * np.random.randn(10000)

n,bins,patches = plt.hist(x,bins=100)

bins

y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
plt.plot(y)

num_bins = 50
n,bins,patches = plt.hist(x, num_bins, density=1)
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
plt.plot(bins,y)



x

def mean(x):
    return np.sum(x)/x.shape[0]

def var(x):
    return mean((x - mean(x))**2)

def std(x):
    return np.sqrt(var(x))

def median(x):
    n = len(x)
    sorted_x = np.sort(x)
    mid = n // 2
    if n % 2 == 0:
        return (sorted_x[mid - 1] + sorted_x[mid]) / 2
    else:
        return sorted_x[mid]

def mode(x):
    values, counts = np.unique(x, return_counts=True)
    max_count_index = np.argmax(counts)
    return values[max_count_index]

def range(x):
    return np.max(x) - np.min(x)

data = np.array([1, 2, 2, 3, 4, 5, 5, 5, 6])

# Testing the functions
mean_value = mean(data)
var_value = var(data)
std_value = std(data)
median_value = median(data)
mode_value = mode(data)
range_value = range(data)

mean_value, var_value, std_value, median_value, mode_value, range_value



"""# Homework



"""



"""# Pi from Random Numbers"""

N = 10

points = -1 + 2*np.random.random((N,2))

points

plt.plot(points[:,0],points[:,1],'.')

plt.gca().set_aspect(1)

inside_circle  = points[:,0]**2 + points[:,1]**2  <=  1
outside_circle = points[:,0]**2 + points[:,1]**2  > 1

plt.plot(points[inside_circle,0],points[inside_circle,1],'g.')
plt.plot(points[outside_circle,0],points[outside_circle,1],'r.')


plt.gca().set_aspect(1)

np.sum(inside_circle),np.sum(outside_circle)

total_area = 4

fraction_inside = np.sum(inside_circle)/N

fraction_inside*total_area

N = 100000000
points = -1 + 2*np.random.random((N,2))
inside_circle  = points[:,0]**2 + points[:,1]**2  <=  1
fraction_inside = np.sum(inside_circle)/N
fraction_inside*4

"""# Complete Code for Estimating π using Monte Carlo Simulation"""

# Number of random points to generate
num_points = 10000

# Generating random points
x_points = np.random.uniform(-1, 1, num_points)
y_points = np.random.uniform(-1, 1, num_points)

# Calculating the number of points inside the quarter circle
points_inside = np.sqrt(x_points**2 + y_points**2) <= 1
num_inside = np.sum(points_inside)

# Estimating π
pi_estimate = 4 * num_inside / num_points

# Plotting the points and the quarter circle
plt.figure(figsize=(6, 6))
plt.scatter(x_points[points_inside], y_points[points_inside], color='green', label='Inside')
plt.scatter(x_points[~points_inside], y_points[~points_inside], color='red', label='Outside')
circle = plt.Circle((0, 0), 1, color='blue', fill=False)
plt.gca().add_artist(circle)
plt.title('Estimating π using Monte Carlo Simulation')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.axis('equal')
plt.show()

pi_estimate



"""# e from Random Numbers"""

X = np.random.random((1000000,10))

Y = np.cumsum(X,1)

Z = np.argmax(Y > 1,1) + 1

np.mean(Z)

np.mean(np.argmax(np.cumsum(np.random.random((10000000,10)),1) > 1,1) + 1)

np.exp(1)

"""# Further Reading:

### Quantum Random Numbers API

https://aws.amazon.com/marketplace/pp/prodview-246kyrfjo3bag
"""